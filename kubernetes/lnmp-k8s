#!/usr/bin/env bash

KUBECTL_URL="https://storage.googleapis.com/kubernetes-release/release"

# copy .env
if ! [ -f .env ];then cp .env.example .env; fi
if ! [ -f coreos/.env ];then cp coreos/.env.example coreos/.env; fi
if ! [ -f systemd/.env ];then cp systemd/.env.example systemd/.env; fi
if ! [ -f volumes/.env ];then cp volumes/.env.example volumes/.env; fi

source ./systemd/.env.example
source ./systemd/.env
source ./.env.example
source ./.env

TMP_ROOT=$HOME/.lnmp/caches

# HELM_SERVICES=("redis" "mysql" "nginx-php" "registry")

################################################################################

if ! [ -f lnmp-k8s ];then if ! [ -z "$LNMP_PATH" ];then cd $LNMP_PATH/kubernetes > /dev/null; else exit; fi; fi

if [ -n "${DEBUG}" ];then
  set -x
fi

source_path=$PWD

if [ -n "${CI_KUBERNETES_VERSION}" ];then
  KUBERNETES_VERSION=${CI_KUBERNETES_VERSION}
fi

set -e

OS=`uname -s`

print_info(){
  echo ""
  echo "==> $1"
  echo ""
}

print_help_info(){
  echo "
Kubernetes version is ${KUBERNETES_VERSION}


Usage: lnmp-k8s COMMAND

Commands:
  kubernetes-server      Download kubernetes server files [--url ] {GOOS} {GOARCH} {TYPE:-server} {KUBERNETES_VERSION:-${KUBERNETES_VERSION}}
  pull-k8s-image         Use By developer Only {GOOS} {GOARCH} {TYPE:-server} {KUBERNETES_VERSION:-${KUBERNETES_VERSION}}

  kubectl-install        Install kubectl
  kubectl-getinfo        Get kubectl latest version info

  minikube-install       Install minikube
  minikube-up            Start minikube

  local-install          Install local Kubernetes（Manager by systemd）[--containerd | --crio | ]
  local-up               Print how to start local Kubernetes (Manager by systemd)
  local-cleanup          Cleanup local Kubernetes.

  join                   New worker [NODE_IP] [--containerd | --crio | ]

  create                 Deploy lnmp on k8s [--ingress | --no-nfs ]
  delete                 Stop lnmp on k8s, keep data resource(pv and pvc)
  cleanup                Stop lnmp on k8s, and remove all resource(pv and pvc)

  registry               Up Registry [--no-nfs | ]

  create-pv              Create PV and PVC [--no-nfs | ]

  nfs                    Up NFS server [ down | logs ]

  helm-development       Install Helm LNMP In Development
  helm-testing           Install Helm LNMP In Testing
  helm-staging           Install Helm LNMP In Staging
  helm-production        Install Helm LNMP In Production
"
}

_sudo(){
  command -v sudo > /dev/null && echo sudo
}

$(_sudo) mkdir -p ${K8S_ROOT}
$(_sudo) mkdir -p ${K8S_ROOT}/bin
$(_sudo) mkdir -p ${K8S_ROOT}/conf
$(_sudo) mkdir -p ${K8S_ROOT}/certs
mkdir -p ${TMP_ROOT} || TMP_ROOT=/tmp

export PATH=${K8S_ROOT}/bin:$PATH

case `uname -m` in
  x86_64 )
  GOARCH=amd64
  ;;
  armv7l )
  GOARCH=arm
  ;;
  aarch64 )
  GOARCH=arm64
esac

GOOS=`uname -s | tr A-Z  a-z`

_build_k8s_image(){
  cd kubernetes-release

  if [ -z "${CI_KUBERNETES_VERSION}" ];then
    CI_KUBERNETES_VERSION=${KUBERNETES_VERSION}
  fi

  if [ -z "${KUBERNETES_TYPE}" ];then
    KUBERNETES_TYPE=server
  fi

  set -x
  docker buildx build \
    --build-arg KUBERNETES_VERSION=v${CI_KUBERNETES_VERSION} \
    --build-arg TYPE=${KUBERNETES_TYPE} \
    --platform linux/amd64,linux/arm64,linux/arm/v7 \
    --push \
    -t khs1994/kubernetes-${KUBERNETES_TYPE}:v${CI_KUBERNETES_VERSION} \
    -t uswccr.ccs.tencentyun.com/khs1994/kubernetes-${KUBERNETES_TYPE}:v${CI_KUBERNETES_VERSION} \
    -f Dockerfile.buildx .
  set +x
  cd .. > /dev/null
}

_get_kubernetes_server_by_docker_image(){
  local TYPE=server
  test -n "${1}" && local GOOS=$1
  test -n "${2}" && local GOARCH=$2
  test -n "${3}" && local TYPE=$3
  test -n "${4}" && local KUBERNETES_VERSION=$4

  if [ -f kubernetes-release/release/kubernetes-${TYPE}-${GOOS}-${GOARCH}-${KUBERNETES_VERSION}.tar.gz ];then
     print_info "Already download"
     return
  fi

  if [ -z "${K8S_IMAGE}" ];then
    K8S_IMAGE=ccr.ccs.tencentyun.com/khs1994/kubernetes-${TYPE}-${GOOS}-${GOARCH}
  fi

  sudo docker manifest inspect ${K8S_IMAGE}:v${KUBERNETES_VERSION} || _build_k8s_image
  docker container rm khs1994-kubernetes-${TYPE} > /dev/null 2>&1 || true
  docker container create --name khs1994-kubernetes-${TYPE} \
    ${K8S_IMAGE}:v${KUBERNETES_VERSION} command
  docker container ls -a --filter name=khs1994-kubernetes-${TYPE}
  docker container cp khs1994-kubernetes-${TYPE}:/kubernetes-${TYPE}-${GOOS}-${GOARCH}.tar.gz kubernetes-release/release/kubernetes-${TYPE}-${GOOS}-${GOARCH}-${KUBERNETES_VERSION}.tar.gz
  docker container rm khs1994-kubernetes-${TYPE}
}

_get_kubernetes_server_by_url(){
  curl https://storage.googleapis.com/kubernetes-release/release/stable.txt \
    && ( \
      curl -L https://storage.googleapis.com/kubernetes-release/release/v${KUBERNETES_VERSION}/kubernetes-server-${GOOS}-${GOARCH}.tar.gz \
        -o kubernetes-release/release/kubernetes-server-${GOOS}-${GOARCH}-${KUBERNETES_VERSION}.tar.gz \
    ) && return 0 || return 1
}

_kubernetes_server_install(){
  if [ "$1" = "--url" ];then
    local get_by_url=1
    shift 1
  fi

  test -n "${1}" && local GOOS=$1
  test -n "${2}" && local GOARCH=$2
  test -n "${3}" && local TYPE=$3
  test -n "${4}" && local KUBERNETES_VERSION=$4

  __untar(){
    test -n "${1}" && local GOOS=$1
    test -n "${2}" && local GOARCH=$2
    test -n "${3}" && local TYPE=$3
    test -n "${4}" && local KUBERNETES_VERSION=$4
    tar -zxvf kubernetes-server-${GOOS}-${GOARCH}-${KUBERNETES_VERSION}.tar.gz
    # pwd => kubernetes-release/release/
    mv kubernetes v${KUBERNETES_VERSION}-${GOOS}-${GOARCH}/
  }

print_info "install kubernetes ..."

if [ -d kubernetes-release/release/v${KUBERNETES_VERSION}-${GOOS}-${GOARCH}/kubernetes/server/bin ];then
  print_info "Kubernetes files existed"
  return
fi

mkdir -p kubernetes-release/release/v${KUBERNETES_VERSION}-${GOOS}-${GOARCH}

  # set +e
  # _get_kubernetes_server_by_url
  #
  # if [ $?=0 ];then
  #   __untar && return || true
  # fi
  # set -e

  test $GOOS != 'linux' && exit

  if [ -n "$get_by_url" ];then
    _get_kubernetes_server_by_url $@
    cd kubernetes-release/release
    __untar $@

    return
  fi

  command -v docker > /dev/null

  if [ $? -eq 0 ];then
    docker container ls > /dev/null 2>&1
    _get_kubernetes_server_by_docker_image $@
    cd kubernetes-release/release
    __untar $@
  fi
}

_delete_lnmp(){
  kubectl delete deployment -l app=lnmp -n lnmp
  kubectl delete service -l app=lnmp -n lnmp
  kubectl delete secret -l app=lnmp -n lnmp
  kubectl delete configmap -l app=lnmp -n lnmp

  kubectl delete cronjob -l app=lnmp -n lnmp
}

_minikube_up(){
  if [ `uname -s` = 'Darwin' ];then
    minikube start \
      -v 10 \
      --registry-mirror=https://dockerhub.azk8s.cn \
      --vm-driver="hyperkit" \
      --memory=4096
  else
    minikube start \
      -v 10 \
      --registry-mirror=https://dockerhub.azk8s.cn \
      --vm-driver="none"
  fi
}

_minikube_install(){
  url=http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v${MINIKUBE_VERSION}/minikube-${GOOS}-amd64

  curl -L $url -o minikube

  chmod +x minikube

  sudo mv minikube /usr/local/bin/ || echo "Please move minikube to your PATH"
}

_cleanup_lnmp(){
  _delete_lnmp
  kubectl delete pvc -l app=lnmp -n lnmp
  kubectl delete pv -l app=lnmp -n lnmp
  kubectl delete ingress -l app=lnmp -n lnmp
}

_create_pv(){
  if [ "$OS" = 'Linux' ];then
    if [ "${1}" = '--no-nfs' ];then
      sed "s#/home/username#$HOME#g" deployment/pv/lnmp-volume.linux.example.yaml \
      | kubectl create -f -

      kubectl -n lnmp create -f deployment/pvc/lnmp-pvc.yaml

      return
    fi

    kubectl create -f deployment/pv/lnmp-volume.linux.nfs.yaml
    kubectl -n lnmp create -f deployment/pvc/lnmp-pvc.linux.nfs.yaml
  elif [ "$OS" = 'Darwin' ];then
    sed "s#/Users/username#$HOME#g" deployment/pv/lnmp-volume.macos.example.yaml \
    | kubectl create -f -

    kubectl -n lnmp create -f deployment/pvc/lnmp-pvc.yaml
  fi
}

_registry_up(){
  kubectl -n lnmp create configmap lnmp-registry-conf-0.0.1 --from-file=config.yml=helm/registry/config/config.development.yml
  kubectl -n lnmp label configmap lnmp-registry-conf-0.0.1 app=lnmp version=0.0.1

  kubectl -n lnmp create secret generic lnmp-registry-tls-0.0.1 --from-file=tls.crt=helm/registry/config/ssl/public.crt \
      --from-file=tls.key=helm/registry/config/ssl/private.key
  kubectl -n lnmp label secret lnmp-registry-tls-0.0.1 app=lnmp version=0.0.1

  kubectl -n lnmp create -f addons/registry.yaml
}

_create_lnmp(){
  current_context=`kubectl config current-context`

  if [ $current_context != "docker-desktop" -a "$OS" = 'Darwin' ];then
     echo "This Script Support Docker Desktop Only On macOS"
     exit
  fi

  kubectl create namespace lnmp > /dev/null 2>&1 || true

  _create_pv "$@"

  kubectl -n lnmp create configmap lnmp-php-conf-0.0.1 \
             --from-file=php.ini=helm/nginx-php/config/php/ini/php.development.ini \
      --from-file=zz-docker.conf=helm/nginx-php/config/php/zz-docker.development.conf \
--from-file=composer.config.json=helm/nginx-php/config/php/composer/config.development.json \
          --from-file=docker.ini=helm/nginx-php/config/php/conf.d/docker.development.ini
  kubectl -n lnmp label configmap lnmp-php-conf-0.0.1 app=lnmp version=0.0.1

  kubectl -n lnmp create configmap lnmp-mysql-cnf-0.0.1 \
   --from-file=docker.cnf=helm/mysql/config/docker.development.cnf
  kubectl -n lnmp label configmap lnmp-mysql-cnf-0.0.1 app=lnmp version=0.0.1

  kubectl -n lnmp create configmap lnmp-nginx-conf-0.0.1 \
   --from-file=nginx.conf=helm/nginx-php/config/nginx/nginx.development.conf
  kubectl -n lnmp label configmap lnmp-nginx-conf-0.0.1 app=lnmp version=0.0.1

  kubectl -n lnmp create configmap lnmp-nginx-conf-d-0.0.1 --from-file=deployment/configMap/nginx-conf-d
  kubectl -n lnmp label configmap lnmp-nginx-conf-d-0.0.1 app=lnmp version=0.0.1

  kubectl -n lnmp create -f deployment/lnmp-configMap.yaml

  kubectl -n lnmp create -f deployment/lnmp-secret.yaml

  kubectl -n lnmp create -f deployment/mysql/lnmp-mysql.yaml

  kubectl -n lnmp create -f deployment/redis/lnmp-redis.yaml

  kubectl -n lnmp create -f deployment/php/lnmp-php7.yaml

  kubectl -n lnmp create -f deployment/nginx/lnmp-nginx.yaml

  if [ "$OS" = 'Linux' ];then
    kubectl -n lnmp create -f deployment/nginx/lnmp-nginx.service.linux.yaml
  elif [ "$OS" = 'Darwin' ];then
    kubectl -n lnmp create -f deployment/nginx/lnmp-nginx.service.yaml
  fi
}

kubectl_install(){
  if [ "$OS" = 'Linux' ];then
    command -v docker > /dev/null
    if [ $? -eq 0 ];then
      docker container rm -f khs1994-kubectl > /dev/null 2>&1 || true
      docker container create --name=khs1994-kubectl khs1994/k8s-cfssl
      docker container cp khs1994-kubectl:/usr/local/bin/kubectl .
      docker container rm -f khs1994-kubectl
      sudo mv kubectl /usr/local/bin
      kubectl version
      return
    fi
  fi

  KUBECTL_VERSION=$(curl https://storage.googleapis.com/kubernetes-release/release/stable.txt)

  curl -fsSL ${KUBECTL_URL}/${KUBECTL_VERSION}/bin/${GOOS}/${GOARCH}/kubectl \
      -o ${TMP_ROOT}/kubectl-${GOOS}-${GOARCH}

  sudo mv ${TMP_ROOT}/kubectl-${GOOS}-${GOARCH} /usr/local/bin/kubectl

  kubectl version
}

kubectl_getinfo(){
  echo "kubectl latest version is
  "
  curl https://storage.googleapis.com/kubernetes-release/release/stable.txt
}

_nginx_build(){
  local url="https://nginx.org/download/"
  local TAR_FILE="nginx-${NGINX_VERSION}.tar.gz"
  __download(){
    sudo curl -fsSL ${url}/${TAR_FILE} -o ${TMP_ROOT}/${TAR_FILE}
  }

  if [ -f ${K8S_ROOT}/kube-nginx.tar.gz ];then
    print_info "${K8S_ROOT}/kube-nginx.tar.gz already exists"
    return
  fi

  print_info "build nginx ..."

  if [ -f ${TMP_ROOT}/${TAR_FILE} ];then
    true
  else
    rm -rf ${TMP_ROOT}/${TAR_FILE}
    __download
  fi

  sudo mkdir -p ${TMP_ROOT}/kube-nginx
  sudo tar -zxvf ${TMP_ROOT}/${TAR_FILE} -C ${TMP_ROOT}/kube-nginx
  cd ${TMP_ROOT}/kube-nginx/nginx-${NGINX_VERSION}

  sudo ./configure --prefix=/opt/k8s/kube-nginx \
    --with-stream --without-http \
    --without-http_uwsgi_module \
    --without-http_scgi_module --without-http_fastcgi_module

  sudo make
  sudo make install
  cd /opt/k8s/
  sudo tar -zcvf kube-nginx.tar.gz kube-nginx
  sudo cp kube-nginx.tar.gz ${TMP_ROOT}/
  cd $source_path
  sudo rm -rf ${TMP_ROOT}/kube-nginx
}

_etcd_install(){
  # local url="https://github.com/etcd-io/etcd/releases/download"
  local url="https://mirrors.huaweicloud.com/etcd"
  local TAR_FILE="etcd-v${ETCD_VERSION}-${GOOS}-${GOARCH}.tar.gz"
  __download(){
    sudo curl -fsSL ${url}/v${ETCD_VERSION}/${TAR_FILE} -o ${TMP_ROOT}/${TAR_FILE}
  }

  if [ -f ${K8S_ROOT}/bin/etcd -a ! "$1" = "--dry-run" ];then
    print_info "etcd already install"
    return
  fi

  print_info "install etcd ..."

  if [ -f ${TMP_ROOT}/${TAR_FILE} ];then
    true
  else
    rm -rf ${TMP_ROOT}/${TAR_FILE}
    __download
  fi

  if [ "$1" = "--dry-run" ];then
    print_info "download etcd success"
    return
  fi

  sudo tar -zxf ${TMP_ROOT}/${TAR_FILE} -C ${TMP_ROOT}
  sudo cp ${TMP_ROOT}/etcd-v${ETCD_VERSION}-${GOOS}-${GOARCH}/etcd* ${K8S_ROOT}/bin/
  sudo chown -R root:root ${K8S_ROOT}/bin/
  sudo rm -rf ${TMP_ROOT}/etcd-v${ETCD_VERSION}-${GOOS}-${GOARCH}
}

_flanneld_install(){
  local url="https://github.com/coreos/flannel/releases/download"
  local TAR_FILE="flannel-v${FLANNEL_VERSION}-${GOOS}-${GOARCH}.tar.gz"
  __download(){
    sudo curl -fsSL ${url}/v${FLANNEL_VERSION}/${TAR_FILE} -o ${TMP_ROOT}/${TAR_FILE}
  }

  if [ -f ${K8S_ROOT}/bin/flanneld -a ! "$1" = "--dry-run" ];then
    print_info "flanneld already install"
    return
  fi

  print_info "install flanneld ..."

  if [ -f ${TMP_ROOT}/${TAR_FILE} ];then
    true
  else
    __download
  fi

  if [ "$1" = "--dry-run" ];then
    print_info "download flanneld success"
    return
  fi

  sudo tar -zxf ${TMP_ROOT}/${TAR_FILE} -C ${K8S_ROOT}/bin/
  sudo chown -R root:root ${K8S_ROOT}/bin/
}

_helm_install(){
  if [ -f ${K8S_ROOT}/bin/helm -a ! "$1" = "--dry-run" ];then
    print_info "helm already install"
    return
  fi

  local url="https://mirrors.huaweicloud.com/helm/v${HELM_VERSION}"
  local TAR_FILE="helm-v${HELM_VERSION}-${GOOS}-${GOARCH}.tar.gz"
  __download(){
    sudo curl -fsSL ${url}/${TAR_FILE} -o ${TMP_ROOT}/${TAR_FILE}
  }

  print_info "install helm ..."

  if [ -f ${TMP_ROOT}/${TAR_FILE} ];then
      local sha256=$(sha256sum ${TMP_ROOT}/${TAR_FILE} | cut -d " " -f 1)
    if ! [ $sha256 = `curl -fsSL ${url}/${TAR_FILE}.sha256` ];then
      rm -rf ${TMP_ROOT}/${TAR_FILE}
      __download
    fi
  else
      __download
  fi

  if [ "$1" = "--dry-run" ];then
    print_info "download helm success"
    return
  fi

  sudo tar -zxf ${TMP_ROOT}/${TAR_FILE} -C ${TMP_ROOT}
  sudo cp ${TMP_ROOT}/${GOOS}-${GOARCH}/helm ${K8S_ROOT}/bin/
  sudo rm -rf ${TMP_ROOT}/${GOOS}-${GOARCH}
}

_gvisor_docker_conf(){
  print_info "config docker with gvisor(runsc) ..."
  echo ""
}

_gvisor_containerd_conf(){
  print_info "config containerd with gvisor(runsc) ..."
  cat <<EOF | sudo tee -a /etc/kube-containerd/config.toml
[plugins.cri.containerd.runtimes.runsc]
  runtime_type = "io.containerd.runsc.v1"
EOF
}

_gvisor_crio_conf(){
  print_info "config crio with gvisor(runsc) ..."
  cat <<EOF | sudo tee -a /etc/crio/crio.conf
[crio.runtime.runtimes.runsc]
  runtime_path = "/usr/local/bin/runsc"
EOF
}

_gvisor_install(){
  print_info "install gvisor ..."
  sudo curl -fsSL -o /usr/local/bin/containerd-shim-runsc-v1 \
    https://github.com/google/gvisor-containerd-shim/releases/download/v0.0.3/containerd-shim-runsc-v1.linux-amd64
  sudo chmod +x /usr/local/bin/containerd-shim-runsc-v1

  sudo curl -fsSL -o /usr/local/bin/runsc \
    https://github.com/docker-practice/gvisor-mirror/releases/download/nightly/runsc

  sudo chmod +x /usr/local/bin/runsc
}

_runc_install(){
  if [ `command -v runc` ];then print_info "runc already install";\
    runc --version;return; fi
  print_info "install runc ..."
}

_containerd_install(){
  if [ `command -v containerd` ];then print_info "containerd already install"; \
    containerd --version;return; fi
  print_info "install containerd ..."
}

_cni_install(){
  sudo mkdir -p /opt/k8s/cni/bin
  if [ -f /opt/k8s/cni/bin/flannel -a ! "$1" = "--dry-run" ];then
    print_info "cni already install"
    return
  fi

  local url="https://github.com/containernetworking/plugins/releases/download/v${CNI_VERSION}"
  local TAR_FILE="cni-plugins-${GOOS}-${GOARCH}-v${CNI_VERSION}.tgz"
  __download(){
    sudo curl -fsSL ${url}/${TAR_FILE} -o ${TMP_ROOT}/${TAR_FILE}
  }

  print_info "install cni ..."

  if [ -f ${TMP_ROOT}/${TAR_FILE} ];then
      local sha256=$(sha256sum ${TMP_ROOT}/${TAR_FILE} | cut -d " " -f 1)
    if ! [ $sha256 = `curl -fsSL ${url}/${TAR_FILE}.sha256 | cut -d " " -f 1` ];then
      sudo rm -rf ${TMP_ROOT}/${TAR_FILE}
      __download
    fi
  else
      __download
  fi

  if [ "$1" = "--dry-run" ];then
    print_info "download cni success"
    return
  fi

  sudo tar -zxf ${TMP_ROOT}/${TAR_FILE} -C /opt/k8s/cni/bin/
}

_crictl_docker_conf(){
  sudo cp systemd/etc/crictl.yaml /etc/crictl.yaml
}

_crictl_containerd_conf(){
  sudo rm -rf /etc/crictl.yaml
  cat <<EOF | sudo tee -a /etc/crictl.yaml
runtime-endpoint: unix:///run/kube-containerd/containerd.sock
image-endpoint: unix:///run/kube-containerd/containerd.sock
timeout: 10
debug: false
EOF
}

_crictl_crio_conf(){
  sudo rm -rf /etc/crictl.yaml
  cat <<EOF | sudo tee -a /etc/crictl.yaml
runtime-endpoint: unix:///var/run/crio/crio.sock
image-endpoint: unix:///var/run/crio/crio.sock
timeout: 10
debug: false
EOF
}

_crictl_install(){
  if [ -f /usr/bin/crictl -a ! "$1" = "--dry-run" ];then
    print_info "crictl already install"
    crictl --version
    return
  fi

  local url="https://github.com/kubernetes-sigs/cri-tools/releases/download/v${CRICTL_VERSION}"
  local TAR_FILE="crictl-v${CRICTL_VERSION}-linux-amd64.tar.gz"
  __download(){
    sudo curl -fsSL ${url}/${TAR_FILE} -o ${TMP_ROOT}/${TAR_FILE}
  }

  print_info "install crictl ..."

  if [ -f ${TMP_ROOT}/${TAR_FILE} ];then
      local sha256=$(sha256sum ${TMP_ROOT}/${TAR_FILE} | cut -d " " -f 1)
    if ! [ $sha256 = "c3b71be1f363e16078b51334967348aab4f72f46ef64a61fe7754e029779d45a" ];then
      sudo rm -rf ${TMP_ROOT}/${TAR_FILE}
      __download
    fi
  else
      __download
  fi

  if [ "$1" = "--dry-run" ];then
    print_info "download crictl success"
    return
  fi

  # sudo tar -zxf ${TMP_ROOT}/${TAR_FILE} -C ${K8S_ROOT}/bin/
  sudo tar -zxf ${TMP_ROOT}/${TAR_FILE} -C /usr/bin/
}

_k8s_install_dep(){
  print_info "install dep ..."
  # 安装依赖软件
  command -v dnf > /dev/null && (sudo dnf install -y conntrack ipvsadm ipset jq iptables curl \
    sysstat libseccomp > /dev/null && sudo /usr/sbin/modprobe ip_vs) || command -v yum > /dev/null && (sudo yum install -y conntrack ipvsadm ipset jq iptables curl \
    sysstat libseccomp > /dev/null && sudo /usr/bin/env modprobe ip_vs) && return

  set +e
  command -v apt > /dev/null && sudo apt update -qq ; sudo apt install -y conntrack ipvsadm ipset jq iptables curl \
    sysstat libseccomp2 kmod > /dev/null && (sudo /usr/bin/env modprobe ip_vs)
  set -e
}

_k8s_install_common(){
  # 关闭防火墙
  sudo systemctl stop firewalld && sudo systemctl disable firewalld || true
  sudo mkdir -p /etc/{docker,systemd/system}
  sudo chmod -R 755 /opt
}

_k8s_install_cp_bin(){
  if ! [ -f ${K8S_ROOT}/bin/kubeadm ];then
    _kubernetes_server_install
    cd $source_path > /dev/null
    sudo cp $PWD/kubernetes-release/release/v${KUBERNETES_VERSION}-${GOOS}-${GOARCH}/kubernetes/server/bin/* ${K8S_ROOT}/bin/
  fi

  sudo cp bin/*.sh ${K8S_ROOT}/bin/

  sudo chmod +x ${K8S_ROOT}/bin/*
}

_k8s_install_systemd_docker(){
  print_info "Update systemd Docker unit file ..."
  sudo mkdir -p /etc/systemd/system/docker.service.d
  sudo cp systemd/docker.conf /etc/systemd/system/docker.service.d/
}

_k8s_install_kubectl_conf(){
  mkdir -p ~/.kube

  if ! [ -f ~/.kube/config ];then
    cp systemd/certs/kubectl.kubeconfig ~/.kube/config
  fi
}

_k8s_install_systemd(){
  cd systemd

  HOSTNAME=${1:-node1}

  for file in `ls *.service`; \
  do \
    if [ ! -f /etc/systemd/system/$file ];then continue ; fi; \
    sudo sed -i "s#/opt/k8s#${K8S_ROOT:-/opt/k8s}#g" \
      /etc/systemd/system/$file ; \
    sudo sed -i "s/192.168.199.100/${MASTER_IP}/g" \
      /etc/systemd/system/$file ; \
    sudo sed -i "s!##NODE_NAME##!${HOSTNAME}!g" \
      /etc/systemd/system/$file ; \
  done

  cd - > /dev/null

  sudo systemctl daemon-reload
}

_cri_config(){
  print_info "config cri ..."
  sudo rm -rf /etc/sysctl.d/99-kubernetes-cri.conf
  sudo touch /etc/sysctl.d/99-kubernetes-cri.conf
  echo "net.bridge.bridge-nf-call-iptables  = 1" | sudo tee -a /etc/sysctl.d/99-kubernetes-cri.conf > /dev/null
  echo "net.ipv4.ip_forward                 = 1" | sudo tee -a /etc/sysctl.d/99-kubernetes-cri.conf > /dev/null
  echo "net.bridge.bridge-nf-call-ip6tables = 1" | sudo tee -a /etc/sysctl.d/99-kubernetes-cri.conf > /dev/null

  # cni conf
  sudo mkdir -p /opt/k8s/cni/net.d
  sudo cp systemd/etc/cni/10-flannel.conflist /opt/k8s/cni/net.d
}

_crio_install(){
  set +e
  command -v crio > /dev/null
  if [ $? -eq 0 ];then print_info "cri-o already install" ; return;fi
  set -e

  print_info "install cri-o ..."

  local CRIO_VERSION_X=`echo $KUBERNETES_VERSION | cut -d "." -f 1`
  local CRIO_VERSION_Y=`echo $KUBERNETES_VERSION | cut -d "." -f 2`
  local CRIO_VERSION="$CRIO_VERSION_X"."$CRIO_VERSION_Y"

  set -x

  command -v dnf > /dev/null && isRPM=1
  command -v yum > /dev/null && isRPM=1

  test -n "$isRPM" && sudo yum install -y \
  btrfs-progs-devel \
  containers-common \
  device-mapper-devel \
  git \
  glib2-devel \
  glibc-devel \
  glibc-static \
  $(command -v go > /dev/null || echo "go") \
  gpgme-devel \
  libassuan-devel \
  libgpg-error-devel \
  libseccomp-devel \
  libselinux-devel \
  pkgconfig \
  runc

  # $(_sudo) sed -i "s#deb.debian.org#mirrors.ustc.edu.cn#g" /etc/apt/sources.list
  # $(_sudo) sed -i "s#security.debian.org#mirrors.ustc.edu.cn#g" /etc/apt/sources.list
  #
  # $(_sudo) sed -i "s#archive.ubuntu.com#mirrors.ustc.edu.cn#g" /etc/apt/sources.list
  # $(_sudo) sed -i "s#security.ubuntu.com#mirrors.ustc.edu.cn#g" /etc/apt/sources.list

  set +e
  command -v apt > /dev/null \
  && $(_sudo) apt update -qq \
  ; $(_sudo) apt install -y software-properties-common \
  && $(_sudo) apt-add-repository -y ppa:projectatomic/ppa \
  && $(_sudo) apt-get update -qq ; $(_sudo) apt-get install -y \
  btrfs-tools \
  containers-common \
  git \
  $(command -v go > /dev/null || echo "golang-go") \
  libassuan-dev \
  libdevmapper-dev \
  libglib2.0-dev \
  libc6-dev \
  libgpgme11-dev \
  libgpg-error-dev \
  libseccomp-dev \
  libsystemd-dev \
  libselinux1-dev \
  pkg-config \
  $(command -v runc > /dev/null || echo "cri-o-runc") \
  libudev-dev \
  gcc

  set -e

  go_path=`go env GOPATH | cut -d ":" -f 1`

  export GOPATH=$go_path

  git clone --depth=1 -b release-${CRIO_VERSION} \
    https://github.com/cri-o/cri-o \
    $go_path/src/github.com/cri-o/cri-o || git clone --depth=1 -b master \
        https://github.com/cri-o/cri-o \
        $go_path/src/github.com/cri-o/cri-o

  if ! [ -d $go_path/src/github.com/cri-o/cri-o ];then
    exit 1
  fi

  cd $go_path/src/github.com/cri-o/cri-o

  go version
  $(_sudo) go version || true
  go env
  $(_sudo) go env || true
  go get github.com/cpuguy83/go-md2man

  make
  # make build-static CONTAINER_RUNTIME=docker
  $(_sudo) PATH=$GOPATH/bin:$PATH GOPATH=$go_path make install.bin
  $(_sudo) PATH=$GOPATH/bin:$PATH GOPATH=$go_path make install.config
  $(_sudo) PATH=$GOPATH/bin:$PATH GOPATH=$go_path make install.systemd

  # command -v yum > /dev/null && sudo yum install cri-o
  #
  # command -v apt > /dev/null && (sudo apt-add-repository -y ppa:projectatomic/ppa \
  #   && sudo apt-get update -qq \
  #   && sudo apt-get install cri-o-$CRIO_VERSION)
  set +x
}

_crio_config(){
  _cni_install
  _crio_install
  cd $source_path
  print_info "config cri-o ..."
  sudo mkdir -p /etc/crio/
  # crio --config="" config --default > crio.conf
  sudo cp systemd/etc/crio/crio.conf /etc/crio/

  _cri_config

  local CONTAINER_RUNTIME_ENDPOINT="unix:///var/run/crio/crio.sock"

  sudo sed -i "s#--container-runtime=docker#--container-runtime=remote#g" /etc/systemd/system/kubelet.service
  sudo sed -i "s#--container-runtime-endpoint=unix:///var/run/dockershim.sock#--container-runtime-endpoint=${CONTAINER_RUNTIME_ENDPOINT}#g" /etc/systemd/system/kubelet.service
}

# https://kubernetes.io/docs/setup/production-environment/container-runtimes/#containerd
_containerd_cri_config(){
  _cni_install
  print_info "config containerd ..."
  sudo mkdir -p /etc/kube-containerd/
  # containerd config default > /etc/kube-containerd/config.toml
  sudo cp systemd/etc/kube-containerd/config.toml /etc/kube-containerd/

  _cri_config

  local CONTAINER_RUNTIME_ENDPOINT="unix:///run/kube-containerd/containerd.sock"

  sudo sed -i "s#--container-runtime=docker#--container-runtime=remote#g" /etc/systemd/system/kubelet.service
  sudo sed -i "s#--container-runtime-endpoint=unix:///var/run/dockershim.sock#--container-runtime-endpoint=${CONTAINER_RUNTIME_ENDPOINT}#g" /etc/systemd/system/kubelet.service
}

_k8s_install(){
  source systemd/.env.example
  source systemd/.env

  if [ ${MASTER_IP} == '192.168.199.100' ];then
    clear
    echo ""
    echo "======================================================"
    echo "==== you must edit MASTER_IP in systemd/.env file ===="
    echo "======================================================"
    echo ""
  fi

  _k8s_install_dep

  _k8s_install_common

  _etcd_install
  _flanneld_install
  _helm_install

  print_info "copy systemd unit file ..."
  sudo cp systemd/*.service /etc/systemd/system/
  sudo cp systemd/certs/*.pem ${K8S_ROOT:-/opt/k8s}/certs/

  if ! [ -f systemd/certs/admin-key.pem ];then \
    echo "Please Generate certs first $ docker-compose up cfssl-local"; exit; fi

  _k8s_install_cp_bin

  print_info "copy kubernetes conf and cert file ..."
  sudo cp systemd/certs/*.kubeconfig ${K8S_ROOT:-/opt/k8s}/conf/
  sudo cp \
    systemd/certs/{audit-policy.yaml,\
kubelet-config.yaml,\
kube-proxy.config.yaml,\
csr-crb.yaml,\
kube-scheduler.yaml,\
encryption-config.yaml} \
    ${K8S_ROOT:-/opt/k8s}/conf/

  local files=("kube-proxy.config.yaml" "kubelet-config.yaml" "kube-scheduler.yaml")

  for file in ${files[@]}; \
  do \
    sudo sed -i "s!##NODE_IP##!${MASTER_IP}!g" \
      ${K8S_ROOT:-/opt/k8s}/conf/$file ; \
    sudo sed -i "s#/opt/k8s#${K8S_ROOT:-/opt/k8s}#g" \
      ${K8S_ROOT:-/opt/k8s}/conf/$file ; \
    sudo sed -i "s!##NODE_NAME##!node1!g" \
      ${K8S_ROOT:-/opt/k8s}/conf/$file ; \
  done

  _k8s_install_systemd

  _gvisor_install
  _crictl_install
  _containerd_install
  _runc_install

  if [ "${1}" = "--containerd" ];then
    print_info "Kubelet Runtime is Containerd"
    _containerd_cri_config
    _gvisor_containerd_conf
    _crictl_containerd_conf
  elif [ "${1}" = "--crio" ];then
    print_info "Kubelet Runtime is CRI-O"
    _crio_config
    _gvisor_crio_conf
    _crictl_crio_conf
  else
    print_info "Kubelet Runtime is Docker"
    sleep 15
    _gvisor_docker_conf
    _k8s_install_systemd_docker
    _crictl_docker_conf
  fi

  sudo systemctl daemon-reload

  sudo useradd -m -s /bin/bash -G root k8s > /dev/null 2>&1 || true

  sudo mkdir --parents /var/log/kubernetes

  sudo mkdir --parents /var/lib/{kubelet,kube-proxy}

  sudo chown k8s:root /var/log/kubernetes

  _k8s_install_kubectl_conf
}

_k8s_join(){
  NODE_IP=$1

  source systemd/.env.example
  source systemd/.env

  test -f systemd/certs/ca.pem || exit 1
  test -f systemd/certs/kubectl.kubeconfig || exit 1
  test -f systemd/certs/flanneld.pem || exit 1
  test -f systemd/certs/flanneld-key.pem || exit 1

  _k8s_install_dep
  _k8s_install_common
  # Flanneld
  _flanneld_install
  _etcd_install
  _helm_install
  sudo cp systemd/flanneld.service /etc/systemd/system/
  # Docker
  # kube-proxy
  sudo cp systemd/kube-proxy.service /etc/systemd/system/
  # kubelet
  sudo cp systemd/kubelet.service /etc/systemd/system/
  # cp pem
  sudo cp systemd/certs/{ca.pem,\
ca-key.pem,\
flanneld-key.pem,\
flanneld.pem} \
${K8S_ROOT:-/opt/k8s}/certs/

  _k8s_install_cp_bin

  print_info "copy kubernetes conf and cert file ..."
  sudo cp \
    systemd/certs/{kubelet-config.yaml,\
kube-proxy.config.yaml,\
csr-crb.yaml,\
kubectl.kubeconfig,\
kube-proxy.kubeconfig} \
    ${K8S_ROOT:-/opt/k8s}/conf

  local files=("kube-proxy.config.yaml" "kubelet-config.yaml")

  HOSTNAME=`hostname`

  for file in ${files[@]}; \
  do \
    sudo sed -i "s!##NODE_IP##!${NODE_IP}!g" \
      ${K8S_ROOT:-/opt/k8s}/conf/$file ; \
    sudo sed -i "s#/opt/k8s#${K8S_ROOT:-/opt/k8s}#g" \
      ${K8S_ROOT:-/opt/k8s}/conf/$file ; \
    sudo sed -i "s!##NODE_NAME##!${HOSTNAME}!g" \
      ${K8S_ROOT:-/opt/k8s}/conf/$file ; \
  done

  _gvisor_install
  _crictl_install
  _containerd_install
  _runc_install

  if [ "${2}" = "--containerd" ];then
    print_info "Kubelet Runtime is Containerd"
    _containerd_cri_config
    _gvisor_containerd_conf
    _crictl_containerd_conf
  elif [ "${2}" = "--crio" ];then
    print_info "Kubelet Runtime is CRI-O"
    _crio_config
    _gvisor_crio_conf
    _crictl_crio_conf
  else
    print_info "Kubelet Runtime is Docker"
    sleep 15
    _gvisor_docker_conf
    _k8s_install_systemd_docker
    _crictl_docker_conf
  fi

  _k8s_install_systemd ${HOSTNAME}

  sudo useradd -m -s /bin/bash -G root k8s > /dev/null 2>&1 || true

  sudo mkdir --parents /var/log/kubernetes

  sudo mkdir --parents /var/lib/{kubelet,kube-proxy}

  sudo chown k8s:root /var/log/kubernetes

  _k8s_install_kubectl_conf
}

_k8s_start(){
  sudo systemctl start kube-apiserver kube-controller-manager kube-scheduler \
                       kube-proxy kubelet
}

_helm_lnmp(){
  cd helm
  lnmp_app_env=$1

  if [ "--debug" = "$2" ];then opt="--dry-run --debug"; fi
  set +e
  for service in ${HELM_SERVICES[@]}
  do
    helm install lnmp-$service-${lnmp_app_env} ./$service \
        --namespace lnmp-${lnmp_app_env} \
        --set APP_ENV=${lnmp_app_env} \
        --set platform=$(uname -s) \
        --set username=$(whoami) \
        $opt
  done
}

_local_start(){
  echo "
$ sudo systemctl start etcd
$ sudo systemctl start flanneld
$ sudo systemctl start docker
$ sudo systemctl start kube-apiserver
$ sudo systemctl start kube-controller-manager
$ sudo systemctl start kube-scheduler
$ sudo systemctl start kube-proxy
$ sudo systemctl start kubelet
"
}

_local_cleanup(){
  sudo systemctl stop etcd flanneld \
    kube-apiserver kube-controller-manager kube-scheduler \
    kube-proxy kubelet \
    docker kube-containerd || true

  set +e
  sudo rm -rf ${K8S_ROOT:-/opt/k8s} \
              /var/lib/etcd \
              /var/log/ku* \
              /var/lib/kubelet \
              /var/lib/kube-proxy \

  sudo rm -rf /etc/systemd/system/docker.service.d

  sudo ip addr flush cni0
  sudo ip addr flush docker0
  sudo ip addr flush flannel.1

  sudo rm -rf /etc/sysctl.d/99-kubernetes-cri.conf

  sudo cp systemd/etc/containerd/docker.toml /etc/containerd/config.toml
  sudo systemctl daemon-reload
  sudo systemctl restart docker containerd
}

if [ -z "$1" ];then
  print_help_info
  exit
fi

_command=$1
shift

if [ "$ENABLE_CN_MIRROR" = 0 ];then
  print_info "CN Mirror disabled"
  sudo sed -i "s#dockerhub.azk8s.cn#mirror.gcr.io#g" `grep dockerhub.azk8s.cn -rl $PWD/systemd` || true
  sudo sed -i "s#gcr.azk8s.cn#gcr.io#g" `grep gcr.azk8s.cn -rl $PWD/systemd` || true
  sudo sed -i "s#gcr.azk8s.cn#gcr.io#g" `grep gcr.azk8s.cn -rl $PWD/addons` || true
fi

case $_command in
    kubernetes-server )
      _kubernetes_server_install $@
      ;;
    pull-k8s-image )
      _get_kubernetes_server_by_docker_image $@
      ;;
    kubectl-install )
      kubectl_install
    ;;
    kubectl-getinfo )
      kubectl_getinfo
    ;;

    create )
      _create_lnmp $@
    ;;

    delete )
      set +e
      _delete_lnmp
    ;;

    cleanup )
      set +e
      _cleanup_lnmp
    ;;

    registry )
      set +e
      _create_pv $@
      _registry_up
    ;;

    create-pv )
      _create_pv $@
    ;;

    local-install )
      _k8s_install $@
    ;;

    local-start )
      _local_start
    ;;

    local-cleanup )
      _local_cleanup
    ;;

    join )
      if [ -z $1 ];then echo "Please Input Node Ip"; exit 1; fi
      _k8s_join $@
    ;;

    minikube-up )
      _minikube_up
    ;;

    minikube-install )
      _minikube_install
    ;;

    helm-development )
    _helm_lnmp development "$@"
    ;;
    helm-testing )
    _helm_lnmp testing "$@"
    ;;
    helm-staging )
    _helm_lnmp staging "$@"
    ;;
    helm-production )
    _helm_lnmp production "$@"
    ;;

    nfs )
    sudo modprobe {nfs,nfsd,rpcsec_gss_krb5}
    sudo modprobe nfsd
    cd volumes
    if [ "$1" = 'down' ];then
      exec docker-compose stop nfs
    elif [ "$1" = 'logs' ]; then
      exec docker-compose logs nfs
    fi
    exec docker-compose up -d nfs

    ;;

    * )
    command -v $_command > /dev/null && $_command $@ || echo "command not found"
    ;;
esac
